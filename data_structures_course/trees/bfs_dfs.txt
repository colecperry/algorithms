# ðŸŒ³ DFS vs BFS in Tree Problems â€” Quick Guide

# âœ… Use DFS (recursive or with a stack) when:
# - You need to visit every node and combine data (e.g., sum, merge, max depth)
#   â†’ DFS naturally dives into subtrees, making it easy to combine results bottom-up.
# - You're building up answers using subtree results (like in postorder traversal)
#   â†’ Recursive DFS mirrors the tree structure and is great for divide-and-conquer logic.
# - You need to explore all paths or use backtracking (e.g., path sum problems)
#   â†’ DFS makes it easy to track the current path using the call stack.
# - You're processing children before the parent or need full control over traversal order
#   â†’ Postorder/inorder logic is much easier with DFS.
# - The problem doesn't care about "levels" or "distances" from root
#   â†’ DFS is simpler when layer info isnâ€™t needed.

# âœ… Use BFS (with a queue) when:
# - You need to process nodes level-by-level (e.g., level order, zigzag traversal)
#   â†’ BFS processes one level at a time, which is perfect for layered logic.
# - You want the shortest path or minimum steps to a node (e.g., closest leaf)
#   â†’ BFS finds the shortest path in an unweighted tree/graph by nature.
# - The problem asks for "top to bottom" or "layer-wise" behavior
#   â†’ This is a clear signal that level order matters â€” perfect for BFS.
# - You're worried about recursion depth or stack overflow on deep trees
#   â†’ BFS is iterative and avoids hitting Pythonâ€™s recursion limit.

# ðŸ§  Tip: If recursion feels natural and no level info is needed, start with DFS.
#        If the problem talks about levels, shortest paths, or early exits, go with BFS.
